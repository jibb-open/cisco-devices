import xapi from "xapi"
import { JIBB } from "./#JSSDKFileName#"
let JSSDKVersion = "#JSSDKVersion#"
let ApiKey = "YourApiKey"
let RecordingEmail = ""
let MeetingAPI = JIBB.Meeting
let Auth = JIBB.Auth
let EventBus = JIBB.EventBus
let Recording = JIBB.Recording
let ShareMeetingStatus = JIBB.ShareMeetingStatus

let recordingStartInFlight = false;

const MEETING_STATE = {
	NONE: "NONE",
	TEAMS: "TEAMS",
	WEBEX: "WEBEX",
};

const DEVICE_MODE = {
	WEBEX: "webex",
	MTR: "mtr",
};

let deviceMode = DEVICE_MODE.WEBEX;

const MEETING_PROVIDER = {
	WEBEX: "webex",
	TEAMS: "microsoft",
	UNKNOWN: "unknown",
};

const SurfaceType = {
	PAPER: "PAPER",
	WHITEBOARD: "WHITEBOARD",
}

function getHostname(url) {
	const match = url.match(/^(?:https?:\/\/)?(?:www\.)?([^\/:]+)/i);
	return match && match[1];
}

function Config(apiKey) {
	this.apiKey = apiKey
	this.webURL = "#WebAppUrl#"
	JIBB.Config.setApiBaseURL("#ApiUrl#")
	JIBB.Auth.configure({ apiKey })
}


let SessionDetails = {
	meetingId: "",
	meetingToken: "",
	userToken: "",
	meetingUrl: "",
	cameraId: "",
	clientId: "",
	selectedInput: 1,

	isJibbRunning: false,
	externalMeetingId: null,
	provider: null,
	isRecordingInProgress: false,
};

let CurrentDeviceCameraSettings = {
	SettingsCleared: true,
	PresenterTrack: false,
	SpeakerTrack: "null",
	Pan: 0,
	Tilt: 0,
	Zoom: 0,
}

function asBool(v) {
	return v === true || v === "True" || v === "true" || v === 1 || v === "1";
}

async function getTeamsInCall() {
	const v = await safe(() => xapi.Status.MicrosoftTeams.Calling.InCall.get(), "Teams.Calling.InCall");
	return asBool(v);
}

async function getMeetingState() {
	// Always check Teams first (safe even on non-MTR: it will return null/false)
	const inTeamsCall = await getTeamsInCall();
	if (inTeamsCall) return MEETING_STATE.TEAMS;

	// Then check RoomOS call stack
	const calls = await safe(() => xapi.Status.Call.get(), "Status.Call.get()");
	if (!Array.isArray(calls) || calls.length === 0) {
		return MEETING_STATE.NONE;
	}

	const call = calls[0];
	const provider = detectMeetingProviderFromCall(call);

	if (provider === MEETING_PROVIDER.TEAMS) return MEETING_STATE.TEAMS;
	if (provider === MEETING_PROVIDER.WEBEX) return MEETING_STATE.WEBEX;

	// If unknown provider but call exists, you can decide your default:
	return MEETING_STATE.WEBEX;
}



async function handleStandaloneRecordingFlow(title) {
	logIfRunning("[JIBB][NONE] standalone flow started");

	const ok = await ensureMeetingContextReady({ needUrl: false, timeoutMs: 25000 });
	if (!ok) return;

	try {
		const payload = {
			sensivityLevel: 2,
			meetingId: SessionDetails.meetingId,
			meetingToken: SessionDetails.meetingToken,
			title,
			// no alternativeEmail, no deviceSerialNumber
		};

		console.log("[JIBB][NONE][Rec] payload:", payload);

		await Recording.startRecording(payload);
		SessionDetails.isRecordingInProgress = true;
		logIfRunning("[JIBB][NONE] Recording started");
	} catch (err) {
		console.log("[JIBB][NONE] Recording Error:", err);
	}
}


async function waitUntil(predicate, timeoutMs = 20000, intervalMs = 250) {
	const start = Date.now();
	while (Date.now() - start < timeoutMs) {
		try {
			if (await predicate()) return true;
		} catch { }
		await sleep(intervalMs);
	}
	return false;
}

async function ensureMeetingContextReady({ needUrl = false, timeoutMs = 25000 } = {}) {
	// Wait for meetingId (autoStartMeeting sets it early)
	const hasMeetingId = await waitUntil(() => !!SessionDetails.meetingId, timeoutMs, 250);
	if (!hasMeetingId) {
		console.log("[JIBB] Meeting context not ready: missing meetingId");
		return false;
	}

	// If meetingToken isn't ready yet, try to fetch it here (race-safe)
	if (!SessionDetails.meetingToken) {
		try {
			await gettingMeetingToken();
		} catch (e) {
			console.log("[JIBB] gettingMeetingToken failed (will keep waiting):", e?.message || e);
		}
	}

	const hasMeetingToken = await waitUntil(() => !!SessionDetails.meetingToken, timeoutMs, 250);
	if (!hasMeetingToken) {
		console.log("[JIBB] Meeting context not ready: missing meetingToken");
		return false;
	}

	if (needUrl) {
		const hasUrl = await waitUntil(() => !!SessionDetails.meetingUrl, timeoutMs, 250);
		if (!hasUrl) {
			console.log("[JIBB] Meeting context not ready: missing meetingUrl (Teams share needs it)");
			return false;
		}
	}

	return true;
}

function registerTeamsCallHandlers() {
	// fires when Teams call starts/ends (works in MTR mode)
	try {
		xapi.Status.MicrosoftTeams.Calling.InCall.on(async (v) => {
			deviceMode = DEVICE_MODE.MTR; // Teams stack exists => this is MTR

			const inCall = asBool(v);
			console.log("[JIBB][Teams] InCall changed:", inCall);

			if (inCall) {
				if (!SessionDetails.isJibbRunning) return;

				// meeting connected start Teams flow (share+record)
				SessionDetails.provider = MEETING_PROVIDER.TEAMS;
				startRecording().catch(e => console.log("[JIBB] startRecording failed:", e?.message || e));
				return;
			}

			// call ended stop everything
			if (SessionDetails.isJibbRunning) {
				await stopMeeting();

				// update UI toggle
				try {
					await xapi.Command.UserInterface.Extensions.Widget.SetValue({
						WidgetId: "jibb_start_toggle",
						Value: "stop",
					});
				} catch { }
			}
		});
	} catch (e) {
		console.log("[JIBB][Teams] InCall path not available; skipping Teams handlers:", e?.message || e);
	}
}


function registerWebexCallHandlers() {
	xapi.Event.CallDisconnect.on(async () => {

		const wasRunning = SessionDetails.isJibbRunning;

		SessionDetails.externalMeetingId = null;
		SessionDetails.provider = null;


		if (!wasRunning) return;

		logIfRunning("Call disconnected > stopping JIBB...");

		try {
			await stopMeeting();


			try {
				await xapi.Command.UserInterface.Extensions.Widget.SetValue({
					WidgetId: "jibb_start_toggle",
					Value: "stop"
				});
			} catch (uiErr) {
				console.warn("Failed to update toggle UI:", uiErr.message);
			}

			SessionDetails.isJibbRunning = false;

		} catch (err) {
			console.warn("Error stopping JIBB after meeting ended:", err.message);
		}
	});

	xapi.Event.CallSuccessful.on(async () => {
		if (!SessionDetails.isJibbRunning) return;
		logIfRunning("New meeting connected.");

		if (SessionDetails.isRecordingInProgress) {
			logIfRunning("Recording is already in progress > nothing to do.");
			return;
		}

		const calls = await xapi.Status.Call.get();
		const call = calls?.[0];
		if (!call) return;

		// still useful for WEBEX host-email flow
		SessionDetails.provider = detectMeetingProviderFromCall(call);
		SessionDetails.externalMeetingId = await extractExternalMeetingId(call);

		logIfRunning("Provider:", SessionDetails.provider);
		logIfRunning("Meeting Identifier:", SessionDetails.externalMeetingId);

		logIfRunning("CallSuccessful > startRecording...");
		logRecordingContext("CallSuccessful before startRecording");

		startRecording().catch(e =>
			console.log("[JIBB] startRecording failed:", e?.message || e)
		);
	});

}

async function safe(fn, label = "") {
	try {
		return await fn();
	} catch (err) {
		console.log(`Error in ${label}:`, err.message);
		return null;
	}
}

function convertSipToWebLink(sip) {
	const match = sip.match(/^([^@]+)@([^@]+\.webex\.com)$/i);
	if (!match) return null;

	let username = match[1];
	const domain = match[2];

	if (username.startsWith("spark:")) {
		username = username.replace("spark:", "");
	}

	return `https://${domain}/meet/${username}`;
}

function detectMeetingProviderFromCall(call) {
	const name = call.DisplayName || "";
	const cb = call.CallbackNumber || "";
	const proto = call.Protocol || "";

	if (/teams\.microsoft\.com/i.test(cb)) return MEETING_PROVIDER.TEAMS;
	if (/Teams Meeting/i.test(name)) return MEETING_PROVIDER.TEAMS;
	if (/WebRTC/i.test(proto) && /teams/i.test(cb)) return MEETING_PROVIDER.TEAMS;

	if (/\.webex\.com/i.test(cb)) return MEETING_PROVIDER.WEBEX;
	if (/spark:/i.test(cb)) return MEETING_PROVIDER.WEBEX;
	if (/Spark/i.test(proto)) return MEETING_PROVIDER.WEBEX;

	return MEETING_PROVIDER.UNKNOWN;
}


async function getHostEmail(orgId, meetingIdentifier) {
	let qs = [];

	if (meetingIdentifier.meetingNumber)
		qs.push(`webex_meeting_number=${meetingIdentifier.meetingNumber}`);

	if (meetingIdentifier.webLink)
		qs.push(`web_link=${encodeURIComponent(meetingIdentifier.webLink)}`);

	if (qs.length === 0) {
		console.log("No meetingNumber or webLink > skipping getHostEmail");
		return null;
	}

	const queryString = qs.join("&");
	const url = `#ApiUrl#/v1/webex-integration/${orgId}/host?${queryString}`;


	try {
		const response = await xapi.Command.HttpClient.Get({
			Url: url,
			Header: [`x-jibb-user-jwt: ${SessionDetails.userToken}`],
			ResultBody: "PlainText"
		});

		const data = JSON.parse(response.Body || "{}");
		return data.email || null;

	} catch (err) {
		console.log("Failed to fetch host email:", err.message);
		return null;
	}
}

async function extractExternalMeetingId(call) {
	const cb = call.CallbackNumber || "";


	try {
		const meetingNumber = await xapi.Status.Conference.MeetingNumber.get();
		if (meetingNumber && /^\d{9,12}$/.test(meetingNumber)) {
			return { meetingNumber: meetingNumber.trim(), webLink: null };
		}
	} catch { }

	try {
		const pmrUrl = await xapi.Status.Conference.PersonalMeeting.PersonalMeetingURL.get();
		if (pmrUrl && pmrUrl.startsWith("https://")) {
			return { meetingNumber: null, webLink: pmrUrl.trim() };
		}
	} catch { }


	const urlMatch = cb.match(/https:\/\/[^\s]+/i);
	if (urlMatch) {
		return { meetingNumber: null, webLink: urlMatch[0] };
	}


	const numMatch = cb.match(/\b\d{9,12}\b/);
	if (numMatch) {
		return { meetingNumber: numMatch[0], webLink: null };
	}


	const sipMatch = cb.match(/^[^@]+@[^@]+webex\.com$/i);
	if (sipMatch) {
		const webLink = convertSipToWebLink(sipMatch[0]);

		if (webLink) {
			return { meetingNumber: null, webLink };
		}
	}


	return { meetingNumber: null, webLink: null };
}


async function getJibbOrganizationId() {
	try {
		const info = await Auth.getUserClaims();

		if (info.organizationId) {
			return info.organizationId;
		}

		if (info.claims?.data?.organization_id) {
			return info.claims.data.organization_id;
		}
	} catch (e) {
		console.log("Cannot get organizationId:", e.message);
	}
	return null;
}

async function getMeetingProviderAndId() {
	const calls = await xapi.Status.Call.get();
	console.log("[JIBB][DBG] Status.Call.get():", JSON.stringify(calls || [], null, 2));

	if (!calls || calls.length === 0) return null;

	const call = calls[0];
	const provider = detectMeetingProviderFromCall(call);
	const idObj = await extractExternalMeetingId(call);

	return { provider, meetingIdentifier: idObj };
}


async function getDeviceSerialNumber() {
	// Best practical identifier on RoomOS (serial)
	try {
		const sn = await xapi.Status.SystemUnit.Hardware.Module.SerialNumber.get();
		const v = String(sn || "").trim();
		if (!v) {
			console.log("[JIBB][Teams] device serial is empty");
			return null;
		}
		return v;
	} catch (e) {
		console.log("[JIBB][Teams] failed to get SerialNumber:", e?.message || e);
		return null;
	}
}

async function shareTeamsMeetingToChat(deviceSerialNumber) {
	const orgId = await getJibbOrganizationId();
	if (!orgId) throw new Error("Missing organizationId");

	if (!deviceSerialNumber) throw new Error("Missing device_serial_number");
	if (!SessionDetails.meetingId) throw new Error("Missing meetingId");

	const shareId = await MeetingAPI.createTemporaryShare({
		meetingId: SessionDetails.meetingId,
		permission: 13,
	});
	if (!shareId) throw new Error("can not create Share Id");

	const meetingUrl = `${config.webURL}/workspace/${SessionDetails.meetingId}/${shareId}`;
	if (!meetingUrl) throw new Error("Missing meeting_url");

	const url = `#ApiUrl#/v1/microsoft-integration/${orgId}/meeting/share`;

	const payloadStr = JSON.stringify({
		meeting_url: meetingUrl,
		device_serial_number: deviceSerialNumber,
	});

	console.log("[JIBB][Teams] POST", url);
	console.log("[JIBB][Teams] Body JSON:", payloadStr);

	const notify = async (text, durationSeconds = 15) => {
		try {
			await xapi.Command.Audio.Sound.Play({ Sound: "Announcement" });
		} catch (soundErr) {
			console.log("[JIBB][Teams] Audio.Sound.Play failed/unsupported:", soundErr?.message || soundErr);
		}

		try {
			await xapi.Command.UserInterface.Message.Alert.Display({
				Title: "JIBB",
				Text: text,
				Duration: durationSeconds,
			});
		} catch (uiErr) {
			console.log("[JIBB][Teams] Alert.Display failed:", uiErr?.message || uiErr);
		}
	};

	const res = await xapi.Command.HttpClient.Post(
		{
			Url: url,
			Header: [
				"Content-Type: application/json",
				`x-jibb-user-jwt: ${SessionDetails.userToken}`,
			],
			ResultBody: "PlainText",
		},
		payloadStr
	);

	console.log("[JIBB][Teams] Response:", res);

	if (String(res?.StatusCode) !== "200") {
		throw new Error(`meeting/share failed. StatusCode=${res?.StatusCode}`);
	}

	let bodyJson = null;
	try {
		bodyJson = res?.Body ? JSON.parse(res.Body) : null;
	} catch (parseErr) {
		console.log("[JIBB][Teams] Response body is not JSON:", parseErr?.message || parseErr);
	}

	const status = bodyJson?.status ?? bodyJson?.Status;

	switch (JIBB.normalizeShareMeetingStatus(status)) {
		case ShareMeetingStatus.PENDING_BOT:
			await notify(
				"Add JIBB to this meeting: in Microsoft Teams on your (phone/laptop), click Apps in the meeting toolbar (or More (â€¦) Apps), search JIBB, then click Add.",
				60
			);
			return false;

		case ShareMeetingStatus.CURRENT_MEETING_NOT_FOUND:
		case 3:
			await notify(
				"This meeting is not scheduled, so the JIBB app ca not share the JIBB meeting in the chat box",
				15
			);
			return false;

		case ShareMeetingStatus.MICROSOFT_TEAM_NOT_CONNECTED:
		case 4:
			await notify(
				"Something went wrong, so JIBB app ca not share the JIBB meeting in the chat box",
				15
			);
			return false;

		default:
			return true;
	}
}


const checkSystemHealth = async (url) => {
	try {
		const res = await xapi.Command.HttpClient.Get({ ResultBody: 'None', Url: url });
		if (res.StatusCode == 200) {
			console.log(`You have access to ${url}`);
		} else {
			throw new Error(`Unexpected status code: ${res.StatusCode}`);
		}
	} catch (error) {
		console.log(error)
		console.log(`You do not have access to ${url}. Error: ${error}`);
		throw new Error(`You do not have access to JIBB APIs. Error: ${error.message}`);
	}

	try {
		const webEngineMode = await xapi.Config.WebEngine.Mode.get();
		if (webEngineMode !== "On") {
			throw new Error('WebEngine is off');
		}

		const httpClientMode = await xapi.Config.HttpClient.Mode.get();
		if (httpClientMode !== "On") {
			throw new Error('HttpClient is off');
		}
	} catch (error) {
		console.log(error)
		console.log(`You do not have access to device configuration: ${error}`);
		throw new Error(`Device configuration error: ${error.message}`);
	}
};

const getDeviceConfig = async () => {
	let DeviceInfo = {}
	let value = await xapi.Status.SystemUnit.Software.DisplayName.get()
	DeviceInfo.OS = value
	value = await xapi.Status.SystemUnit.ProductId.get()
	DeviceInfo.DeviceType = value

	DeviceInfo.ApiKey = ApiKey
	DeviceInfo.JIBBURI = "#ApiUrl#"
	DeviceInfo.JSSDKVersion = JSSDKVersion

	console.log("*** Device INFO ***")
	console.log(DeviceInfo)
	console.log("*** Device INFO ***")
}

async function generateMeetingLink() {
	console.log("generating meeting link ...")
	let title = await createTitle()
	await gettingUserToken()
	await createMeeting(title)
	SessionDetails.meetingUrl = `${config.webURL}/cisco/devices/${SessionDetails.meetingId}?user_token=${SessionDetails.userToken}`
}

async function createTitle() {
	let title = String(await xapi.Config.SystemUnit.CustomDeviceId.get())
	if (String(title) == "") {
		title = "JIBB Workspace"
	}
	return title
}

async function gettingUserToken() {
	try {
		SessionDetails.userToken = await Auth.getUserToken()
	} catch (err) {
		console.log(`Cannot get user token: ${err}`)
		xapi.Command.UserInterface.Message.Alert.Display({
			Duration: 20,
			Text: "Something went wrong. Please check your API KEY",
			Title: "Error",
		})
		throw ("Cannot get user token. Please check your API KEY")
	}
}

async function gettingMeetingToken() {
	SessionDetails.meetingToken = await MeetingAPI.getMeetingToken({
		meetingId: SessionDetails.meetingId,
		permission: 2,
	})
}

async function createMeeting(title) {
	SessionDetails.meetingId = await MeetingAPI.createMeeting({ title: title, isTemporary: true })
}

async function autoStartMeeting() {
	console.log("autoStartMeeting ...")
	hideJibbPanel()
	hideCameraSelfView()
	await generateMeetingLink()
	await openMeetingUrlInWebView()

	try {
		await getWebClinetId()
		await sleep(3000)
		await safe(getCameraId, "getCameraId");


	} catch (err) {
		console.log(err)
		console.error("Client or camera setup failed:", err.message)
		xapi.Command.UserInterface.Message.Alert.Display({
			Duration: 10,
			Text: "Please contact admin to check device settings",
			Title: "Setup Error",
		});
		return;
	}

	await gettingMeetingToken()
	await startTheMeeting()
	await sleep(5000)

	startRecording().catch(e =>
		console.log("[JIBB] startRecording failed:", e?.message || e)
	);

}


async function startTheMeeting() {
	let req = {
		meetingToken: SessionDetails.meetingToken,
		surfaceType: SurfaceType.WHITEBOARD,
		fixedCorners: true,
		cameraId: SessionDetails.cameraId,
		clientId: SessionDetails.clientId,
		enableColor: true,
	}
	await EventBus.startStream(req)
}


async function getCameraId() {
	try {
		const cameraList = await EventBus.getCameraList(SessionDetails.clientId);
		console.log("Raw camera list received from EventBus.getCameraList():", cameraList);

		if (!Array.isArray(cameraList) || cameraList.length === 0) {
			console.warn("Camera list is empty or not an array.");
			return Promise.reject("No cameras detected or accessible.");
		}

		const validCameras = cameraList.filter(cam => cam?.id?.trim());
		const invalidCameras = cameraList.filter(cam => !cam?.id?.trim());

		validCameras.forEach((cam, i) => {
			console.log(`  [${i + 1}] ID: ${cam.id}, Name: ${cam.name || "N/A"}`);
		});

		if (invalidCameras.length > 0) {
			invalidCameras.forEach((cam, index) => {
				console.warn(`  [${index + 1}] Camera object is invalid or missing 'id':`, cam);
			});
		}

		if (validCameras.length === 0) {
			return Promise.reject("No valid camera ID available.");
		}

		SessionDetails.cameraId = validCameras[0].id;
	} catch (err) {
		console.warn("Error in getCameraId:", err.message);
		return Promise.reject("Camera detection failed: " + err.message);
	}
}

async function getWebClinetId() {
	const maxAttempts = 60;      // up to 60s
	const retryDelayMs = 1000;

	for (let attempt = 1; attempt <= maxAttempts; attempt++) {
		console.log(`[getWebClinetId] attempt ${attempt}/${maxAttempts}`);

		const statusList = await EventBus.getClientStatusList();
		console.log("Full statusList from getClientStatusList():", statusList);

		// normalize possible shapes
		const items = Array.isArray(statusList) ? statusList : (statusList ? [statusList] : []);

		//  prefer WEBAPP client if present
		const webapp = items.find(c =>
			(c?.clientType === "WEBAPP" || c?.type === "WEBAPP") && c?.id
		);

		if (webapp?.id) {
			SessionDetails.clientId = webapp.id;
			return;
		}

		// fallback: any id
		const any = items.find(c => c?.id);
		if (any?.id) {
			SessionDetails.clientId = any.id;
			return;
		}

		await sleep(retryDelayMs);
	}

	console.error("No valid client ID found in status list after retries");
	throw new Error("Unable to get a valid client ID");
}



async function openMeetingUrlInWebView() {
	await xapi.Command.UserInterface.WebView.Display({ Title: "jibb", Url: SessionDetails.meetingUrl });

	//  IMPORTANT: wait until WebView is actually loaded, otherwise client list can stay empty
	await waitForWebViewReady(SessionDetails.meetingUrl, 30000);
}


async function stopMeeting() {
	logIfRunning("stopMeeting...");

	try {
		await stopRecording();
	} catch (err) {
		console.log(err)
		console.warn("Error stopping recording:", err.message);
	}

	try {
		await closeWebView();
	} catch (err) {
		console.log(err)
		console.warn("Error closing WebView:", err.message);
	}

	try {
		await hideCameraSelfView();
	} catch (err) {
		console.log(err)
		console.warn("Error hiding self-view:", err.message);
	}

	try {
		await hideJibbPanel();
	} catch (err) {
		console.log(err)
		console.warn("Error hiding JIBB panel:", err.message);
	}

	try {
		await setDeviceCameraToBeforeSettings();
	} catch (err) {
		console.log(err)
		console.warn("Error restoring camera settings:", err.message);
	}
	SessionDetails.isRecordingInProgress = false;
	SessionDetails.isJibbRunning = false;

	SessionDetails.meetingId = "";
	SessionDetails.meetingToken = "";
	SessionDetails.meetingUrl = "";
	SessionDetails.cameraId = "";
	SessionDetails.clientId = "";
	SessionDetails.externalMeetingId = null;
	SessionDetails.provider = null;

	logRecordingContext("stopMeeting completed");
}

async function handleWebexRecordingFlow(title) {
	logIfRunning("[JIBB][Webex] recording flow started");

	let recordingTargetEmail = RecordingEmail;
	if (recordingTargetEmail) {
		logIfRunning("[JIBB][Webex] Using RecordingEmail:", recordingTargetEmail);
	} else {
		logIfRunning("[JIBB][Webex] -> Host Email lookup...");

		const idObj = SessionDetails.externalMeetingId;
		if (!idObj || (!idObj.meetingNumber && !idObj.webLink)) {
			logIfRunning("[JIBB][Webex] No meetingNumber/webLink -> abort");
			return;
		}

		const orgId = await getJibbOrganizationId();
		const hostEmail = await getHostEmail(orgId, idObj);

		if (!hostEmail) {
			logIfRunning("[JIBB][Webex] Host email not found -> abort");
			return;
		}

		logIfRunning("[JIBB][Webex] Using host email:", hostEmail);
		recordingTargetEmail = hostEmail;
	}

	try {
		const payload = {
			sensivityLevel: 2,
			meetingId: SessionDetails.meetingId,
			meetingToken: SessionDetails.meetingToken,
			title,
			alternativeEmail: recordingTargetEmail
		};

		console.log("[JIBB][Webex][Rec] payload:", payload);

		await Recording.startRecording(payload);

		SessionDetails.isRecordingInProgress = true;
		logIfRunning("[JIBB][Webex] Recording started");
	} catch (err) {
		console.log("[JIBB][Webex] Recording Error:", err);
	}
}


async function handleTeamsRecordingFlow(title) {
	logIfRunning("[JIBB][Teams] flow started");

	// 1) Teams -> get device id
	const deviceSerialNumber = await getDeviceSerialNumber();
	if (!deviceSerialNumber) {
		console.log("[JIBB][Teams] Missing device serial -> abort");
		return;
	}

	// 2) Teams -> ensure meeting is ready (meetingId/meetingToken + meetingUrl for sharing)
	const ok = await ensureMeetingContextReady({ needUrl: true, timeoutMs: 25000 });
	if (!ok) return;

	// 3) Teams -> share meeting
	try {
		await shareTeamsMeetingToChat(deviceSerialNumber);
		logIfRunning("[JIBB][Teams] meeting/share OK (200)");
	} catch (err) {
		console.log("[JIBB][Teams] meeting/share failed:", err?.message || err);
		return;
	}

	// 4) Teams -> start recording
	try {
		const payload = {
			sensivityLevel: 2,
			meetingId: SessionDetails.meetingId,
			meetingToken: SessionDetails.meetingToken,
			title,
			deviceSerialNumber,
		};

		console.log("[JIBB][Webex][Teams] payload:", payload);

		await Recording.startRecording(payload);

		SessionDetails.isRecordingInProgress = true;
		logIfRunning("[JIBB][Teams] Recording started");
	} catch (err) {
		console.log("[JIBB][Teams] Recording Error:", err);
	}
}


function logRecordingContext(tag = "") {
	console.log(`[JIBB][CTX] ${tag}`, {
		isJibbRunning: SessionDetails.isJibbRunning,
		provider: SessionDetails.provider,
		externalMeetingId: SessionDetails.externalMeetingId,
		meetingId: SessionDetails.meetingId,
		hasMeetingToken: !!SessionDetails.meetingToken,
		hasUserToken: !!SessionDetails.userToken,
		hasMeetingUrl: !!SessionDetails.meetingUrl,
		isRecordingInProgress: SessionDetails.isRecordingInProgress,
	});
}

function isNoMatch(err) {
	const msg = String(err?.message || err || "");
	return /No match on Path argument/i.test(msg);
}

async function hasPath(getter, label = "") {
	try {
		await getter();
		return true;
	} catch (e) {
		if (!isNoMatch(e)) {
			console.log(`[JIBB] hasPath unexpected error (${label}):`, e?.message || e);
		}
		return false;
	}
}


async function startRecording() {
	if (SessionDetails.isRecordingInProgress || recordingStartInFlight) return;
	recordingStartInFlight = true;

	try {
		const title = await createTitle();

		if (!SessionDetails.userToken) {
			SessionDetails.userToken = await Auth.getUserToken();
		}

		const state = await getMeetingState();
		console.log("[JIBB] MeetingState:", state);

		if (state === MEETING_STATE.TEAMS) {
			await handleTeamsRecordingFlow(title);
			return;
		}

		if (state === MEETING_STATE.WEBEX) {
			const ok = await ensureMeetingContextReady({ needUrl: false, timeoutMs: 25000 });
			if (!ok) return;

			// Only needed for WEBEX host-email lookup
			if (!SessionDetails.externalMeetingId) {
				const ci = await safe(getMeetingProviderAndId, "getMeetingProviderAndId (webex)");
				if (ci?.meetingIdentifier) SessionDetails.externalMeetingId = ci.meetingIdentifier;
			}

			await handleWebexRecordingFlow(title);
			return;
		}

		// NONE
		await handleStandaloneRecordingFlow(title);

	} finally {
		recordingStartInFlight = false;
	}
}



async function stopRecording() {
	try {
		await Recording.stopRecording();
	} catch (err) {
		console.warn("Cannot stop recording");
	}

	SessionDetails.isRecordingInProgress = false;
}

async function setCameraPreset(positionName) {
	if (CurrentDeviceCameraSettings.SettingsCleared) {
		await getDeviceCurrentCameraSettings();
	}

	try {
		await xapi.Config.Cameras.PresenterTrack.Enabled.set(false);
	} catch (err) {
		console.warn("This device does not have PresenterTrack");
	}

	try {
		await xapi.Command.Cameras.SpeakerTrack.Deactivate();
	} catch (err) {
		console.warn("This device does not have SpeakerTrack");
	}

	const presetNamesToTry = [positionName, "Jibb", "jibb"];

	try {
		const allCameras = await xapi.Status.Cameras.Camera.get();
		console.log("All hardware cameras from xapi.Status.Cameras.Camera.get():", allCameras);

		if (!Array.isArray(allCameras) || allCameras.length === 0) {
			console.warn("No cameras available for preset lookup");
			return;
		}

		for (const cam of allCameras) {
			const camId = cam.id;
			try {
				const { Preset: presets = [] } = await xapi.Command.Camera.Preset.List({
					CameraId: camId,
					DefaultPosition: false
				});

				console.log(`Presets for camera ${camId}:`, presets);

				for (const name of presetNamesToTry) {
					const match = presets.find(preset =>
						preset.Name === name && (!preset.CameraId || preset.CameraId === camId)
					);

					if (match) {
						console.log(`Activating preset '${name}' (ID: ${match.PresetId}) on CameraId: ${camId}`);
						await xapi.Command.Camera.Preset.Activate({ PresetId: match.PresetId });
						return;
					}
				}
			} catch (err) {
				console.warn(`Error while listing presets for camera ${camId}:`, err.message);
			}
		}
	} catch (err) {
		console.warn("Preset activation failed due to camera or preset listing error:", err.message);
	}

	console.warn("No usable preset found on any available camera. Skipping camera position restore.");
}

async function setCameraPosition(positionName) {
	return setCameraPreset(positionName);
}


async function getDeviceCurrentCameraSettings() {
	console.log("getDeviceCurrentCameraSettings");
	try {
		CurrentDeviceCameraSettings.PresenterTrack = await xapi.Config.Cameras.PresenterTrack.Enabled.get();
	} catch (err) {
		console.log(err)
		console.warn("PresenterTrack not available:", err.message);
	}

	try {
		CurrentDeviceCameraSettings.SpeakerTrack = await xapi.Status.Cameras.SpeakerTrack.Status.get();
	} catch (err) {
		console.log(err)
		console.warn("SpeakerTrack not available:", err.message);
	}

	try {
		const cameras = await xapi.Status.Cameras.Camera.get();
		console.log("Cameras found in getDeviceCurrentCameraSettings:", cameras);
		if (Array.isArray(cameras) && cameras.length > 0) {
			const cam = cameras[0];
			CurrentDeviceCameraSettings.Pan = cam.Position?.Pan || 0;
			CurrentDeviceCameraSettings.Tilt = cam.Position?.Tilt || 0;
			CurrentDeviceCameraSettings.Zoom = cam.Position?.Zoom || 0;
		} else {
			console.warn("No camera data found for position.");
		}
	} catch (err) {
		console.log(err)
		console.warn("Error retrieving camera position:", err.message);
	}

	CurrentDeviceCameraSettings.SettingsCleared = false;
}


async function setDeviceCameraToBeforeSettings() {
	console.log("setDeviceCameraToBeforeSettings");

	try {
		if (CurrentDeviceCameraSettings.PresenterTrack) {
			await xapi.Config.Cameras.PresenterTrack.Enabled.set(true);
		}
	} catch (err) {
		console.log(err)
		console.warn("PresenterTrack not supported or failed to re-enable:", err.message);
	}

	try {
		if (CurrentDeviceCameraSettings.SpeakerTrack === "Active") {
			await xapi.Command.Cameras.SpeakerTrack.Activate();
		}
	} catch (err) {
		console.log(err)
		console.warn("SpeakerTrack not supported or failed to re-activate:", err.message);
	}

	try {
		const cameras = await xapi.Status.Cameras.Camera.get();

		if (Array.isArray(cameras) && cameras.length > 0) {
			const cameraId = cameras[0].id || 1;
			await xapi.Command.Camera.PositionSet({
				CameraId: cameraId,
				Pan: CurrentDeviceCameraSettings.Pan,
				Tilt: CurrentDeviceCameraSettings.Tilt,
				Zoom: CurrentDeviceCameraSettings.Zoom,
			});
		} else {
			console.warn("No physical cameras found to reset position.");
		}
	} catch (err) {
		console.log(err)
		console.warn("Camera PositionSet failed or not supported:", err.message);
	}

	clearCurrentDeviceCameraSettings();
}

function clearCurrentDeviceCameraSettings() {
	CurrentDeviceCameraSettings.SettingsCleared = true
	CurrentDeviceCameraSettings.PresenterTrack = false
	CurrentDeviceCameraSettings.SpeakerTrack = "null"
	CurrentDeviceCameraSettings.Pan = 0
	CurrentDeviceCameraSettings.Tilt = 0
	CurrentDeviceCameraSettings.Zoom = 0
}

function closeWebView() {
	return xapi.Command.UserInterface.WebView.Clear({ Target: "OSD" });
}

async function hideCameraSelfView() {
	try {
		return await xapi.Command.Video.Selfview.Set({
			FullscreenMode: "Off",
			Mode: "Off",
			PIPPosition: "LowerRight",
		});
	} catch (e) {
		console.log("[JIBB] Selfview not available:", e?.message || e);
		return null;
	}
}

async function showCameraSelfView() {
	try {
		await xapi.Command.Video.Selfview.Set({
			FullscreenMode: "Off",
			Mode: "On",
			PIPPosition: "LowerRight",
		});
	} catch (e) {
		console.log("[JIBB] Selfview.Set failed:", e?.message || e);
	}
}


function hideJibbPanel() {
	return xapi.Command.UserInterface.Extensions.Panel.Close();
}



function sleep(ms) {
	return new Promise((resolve) => setTimeout(resolve, ms))
}

function showAlert() {
	xapi.Command.UserInterface.Message.Alert.Display({
		Duration: 3,
		Text: "JIBB Ready",
		Title: "JIBB is Ready",
	})
}
function bindWidgetActions() {
	xapi.Event.UserInterface.Extensions.Widget.Action.on(async (event) => {
		if (!["changed", "released", "clicked"].includes(event.Type)) return;

		if (event.WidgetId === "jibb_start_toggle") {
			if (event.Value === "start") {
				if (SessionDetails.isJibbRunning || SessionDetails.isRecordingInProgress || SessionDetails.meetingId) {
					await stopMeeting()
				}
				SessionDetails.isJibbRunning = true;

				await xapi.Command.UserInterface.Extensions.Widget.SetValue({
					WidgetId: "jibb_start_toggle",
					Value: "start"
				});

				await autoStartMeeting()
			}

			if (event.Value === "stop") {
				SessionDetails.isJibbRunning = false;

				await xapi.Command.UserInterface.Extensions.Widget.SetValue({
					WidgetId: "jibb_start_toggle",
					Value: "stop"
				});

				RecordingEmail = "";
				await stopMeeting();
			}
			return;
		}

	});
}

let config = new Config(ApiKey)

async function addPanel() {
	const xml = uiExtension;

	await xapi.Command.UserInterface.Extensions.Panel.Save({ PanelId: "jibb_panel" }, xml);

	try {
		await sleep(400);
		await xapi.Command.UserInterface.Extensions.Widget.SetValue({
			WidgetId: "jibb_start_toggle",
			Value: "start",
		});
	} catch (e) {
		console.log("[JIBB] Toggle not ready yet:", e?.message || e);
	}
}

async function waitForSystemReady({ timeoutMs = 60000, pollMs = 1000 } = {}) {
	const start = Date.now();
	while (Date.now() - start < timeoutMs) {
		try {
			const s = await xapi.Status.SystemUnit.State.System.get(); // "Initializing" / "Initialized" / ...
			if (s === "Initialized") return true;
			console.log("[JIBB] System state:", s, "(waiting)");
		} catch (e) {
			console.log("[JIBB] System state read failed:", e?.message || e);
		}
		await sleep(pollMs);
	}
	return false;
}


async function detectDeviceModeSimple(retries = 10, delayMs = 1000) {
	for (let i = 0; i < retries; i++) {
		const isMtr =
			await hasPath(() => xapi.Status.MicrosoftTeams.User.SignedIn.get(), "Teams.SignedIn") ||
			await hasPath(() => xapi.Status.MicrosoftTeams.Software.VersionCode.TeamsApp.get(), "TeamsApp");

		if (isMtr) return DEVICE_MODE.MTR;
		await sleep(delayMs);
	}
	return DEVICE_MODE.WEBEX;
}

async function waitForWebViewReady(expectedUrl, timeoutMs = 30000) {
	const start = Date.now();
	const base = String(expectedUrl || "").split("?")[0];

	while (Date.now() - start < timeoutMs) {
		const views = await safe(() => xapi.Status.UserInterface.WebView.get(), "Status.UserInterface.WebView.get()");
		const list = Array.isArray(views) ? views : (views ? [views] : []);

		// try to match your meeting URL, otherwise just take the first integration view
		const v =
			list.find(w => String(w?.URL || w?.Url || "").includes(base)) ||
			list.find(w => w?.Type === "Integration") ||
			list[0];

		if (v) {
			const statusOk = v.Status === "Visible";
			const httpOk = String(v.HttpResponseStatusCode) === "200";

			if (statusOk && httpOk) return true;
		}

		await sleep(500);
	}

	console.log("[JIBB] WebView not ready (Visible + 200) before timeout");
	return false;
}

async function waitForCallStackReady({ timeoutMs = 60000, pollMs = 1000 } = {}) {
	const start = Date.now();

	while (Date.now() - start < timeoutMs) {
		try {
			// Check Teams stack (MTR)
			const teamsPath = await hasPath(
				() => xapi.Status.MicrosoftTeams.Calling.InCall.get(),
				"Teams.Calling.InCall"
			);

			// Check Call stack (RoomOS)
			const calls = await safe(() => xapi.Status.Call.get(), "Status.Call.get()");
			const callStackReady = Array.isArray(calls);

			if (teamsPath || callStackReady) {
				console.log("[JIBB] Call stack ready");
				return true;
			}
		} catch { }

		console.log("[JIBB] Waiting for call stack...");
		await sleep(pollMs);
	}

	console.log("[JIBB] Call stack NOT ready before timeout");
	return false;
}


async function main() {

	await waitForSystemReady({ timeoutMs: 120000, pollMs: 1000 });

	await waitForCallStackReady({ timeoutMs: 90000 });

	deviceMode = await detectDeviceModeSimple(15, 1000);
	console.log("[JIBB] DeviceMode:", deviceMode);

	await addPanel(deviceMode);

	// safe to do these after system is up
	try {
		await xapi.Command.WebEngine.MediaAccess.add({
			Hostname: getHostname(config.webURL),
			Device: "Camera",
		});
	} catch (e) { }

	registerWebexCallHandlers();
	registerTeamsCallHandlers();

	reactToJibbClick();
	bindWidgetActions();
	showAlert();

	#mainBody#
}



main().catch(e => console.log("[JIBB] main crashed:", e?.message || e));


function reactToJibbClick() {

	xapi.Event.UserInterface.Extensions.Panel.Clicked.on(async (value) => {
		try {
			if (value.PanelId == "jibb_panel") {
				try {
					await getDeviceConfig()
					await checkSystemHealth("#ApiUrl#/health")
				} catch (err) {
					xapi.Command.UserInterface.Message.Alert.Display({
						Duration: 20,
						Text: "HttpClient, or JIBB API access. Please contact your device admin to check settings.",
						Title: "Essential device settings are missing",
					})
					hideJibbPanel()
					throw (err)
				}

				const state = await getMeetingState();
				if (state === MEETING_STATE.NONE) {
					console.log("No active meeting detected when JIBB clicked.");
				} else {
					console.log("Active meeting detected. State:", state);
				}



				await setCameraPreset(`Jibb${SessionDetails.selectedInput}`).catch(e =>
					console.log("[JIBB] setCameraPreset failed:", e?.message || e)
				);

				await showCameraSelfView()
			}

		} catch (e) {
			console.log("[JIBB] Panel.Clicked handler crashed:", e?.message || e);
		}
	})
}


function logIfRunning(...args) {
	if (SessionDetails.isJibbRunning) {
		console.log(...args);
	}
}

function stringReplace(oldStr, newStr) {
	uiExtension = uiExtension.replace(oldStr, newStr)
}


let uiExtension = `<Extensions>
  <Version>1.11</Version>
  <Panel>
       <Order>1</Order>
	   <PanelId>jibb_panel</PanelId>
	   <Location>#UILocation#</Location>
	   <Icon>Custom</Icon>
	   <Name>JIBB</Name>
	   <ActivityType>Custom</ActivityType>
    <CustomIcon>
      <Content>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</Content>
      <Id>d5c72d04a0311f930447729e1331908693ed5d5494d6e1003149ddb0a4a5ed95</Id>
    </CustomIcon>
    <Page>
      <Name>JIBB</Name>
	  <Row>
        <Name>Row</Name>
        <Widget>
          <WidgetId>widget_3</WidgetId>
          <Name>Instantly Digitize &amp; Share the Meeting Room Whiteboard</Name>
          <Type>Text</Type>
          <Options>size=4;fontSize=normal;align=center</Options>
        </Widget>       
      </Row>
	  <Row>
		<Widget>
			<WidgetId>widget_4</WidgetId>
			<Name>1- Enter email for auto-save PDF (else host receives it)</Name>
			<Type>Text</Type>
			<Options>size=3;fontSize=small;align=left</Options>
		</Widget>

		<Widget>
			<WidgetId>jibb_email</WidgetId>
			<Name>Edit</Name>
			<Type>Button</Type>
			<Options>size=1</Options>
		</Widget>
	</Row>
    <Row>
        <Name>Row</Name>
        <Widget>
          <WidgetId>widget_5</WidgetId>
          <Name>2- Tap Start when you're ready to Launch JIBB Session</Name>
          <Type>Text</Type>
          <Options>size=4;fontSize=small;align=left</Options>
        </Widget>
      </Row>
      <Row>
        <Name>Row</Name>
        <Widget>
		<WidgetId>jibb_start_toggle</WidgetId>
		<Type>GroupButton</Type>
		<Options>size=4</Options>
		<ValueSpace>
			<Value>
			<Key>start</Key>
			<Name>Start</Name>
			</Value>
			<Value>
			<Key>stop</Key>
			<Name>Stop</Name>
			</Value>
		</ValueSpace>
		</Widget>
		</Row>
		<Options>hideRowNames=1</Options>
    </Page>
  </Panel>
</Extensions>`

#InputCode#

#EmailCode#

#CameraControlCode#
